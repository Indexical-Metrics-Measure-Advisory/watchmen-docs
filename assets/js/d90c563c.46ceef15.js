"use strict";(globalThis.webpackChunkwatchmen_docs=globalThis.webpackChunkwatchmen_docs||[]).push([[56598],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},68462:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"data-ingestion/How to Reduce Recognize Complex in Data Ingestion","title":"How to Reduce Recognize Complex in Data Ingestion","description":"Title","source":"@site/docs/030-data-ingestion/How to Reduce Recognize Complex in Data Ingestion.md","sourceDirName":"030-data-ingestion","slug":"/data-ingestion/How to Reduce Recognize Complex in Data Ingestion","permalink":"/docs/next/data-ingestion/How to Reduce Recognize Complex in Data Ingestion","draft":false,"unlisted":false,"editUrl":"https://github.com/Indexical-Metrics-Measure-Advisory/watchmen-docs/tree/main/docs/030-data-ingestion/How to Reduce Recognize Complex in Data Ingestion.md","tags":[],"version":"current","lastUpdatedBy":"luke0623","lastUpdatedAt":1767190806000,"frontMatter":{},"sidebar":"sidebar","previous":{"title":"Table Configuration","permalink":"/docs/next/data-ingestion/configuration-for-change-data-capture/table-config"},"next":{"title":"Admin Workbench Index","permalink":"/docs/next/data-modeling/admin-wb-index"}}');var t=i(74848),r=i(28453);const a={},o=void 0,l={},c=[{value:"The Real Problem: Recognition, Not Just Extraction",id:"the-real-problem-recognition-not-just-extraction",level:2},{value:"Pattern 1: Separate \u201cSource View\u201d from \u201cDomain View\u201d",id:"pattern-1-separate-source-view-from-domain-view",level:2},{value:"Pattern 2: Introduce Ingestion Modules per Domain",id:"pattern-2-introduce-ingestion-modules-per-domain",level:2},{value:"Pattern 3: Make Mapping Explicit and Validated",id:"pattern-3-make-mapping-explicit-and-validated",level:2},{value:"Pattern 4: Design Ingestion as Tasks, Not Scripts",id:"pattern-4-design-ingestion-as-tasks-not-scripts",level:2},{value:"Pattern 5: Normalize Early, Deliver Flexibly",id:"pattern-5-normalize-early-deliver-flexibly",level:2},{value:"Putting It All Together in a SaaS Data Platform",id:"putting-it-all-together-in-a-saas-data-platform",level:2},{value:"Final Thoughts",id:"final-thoughts",level:2}];function d(e){const n={blockquote:"blockquote",br:"br",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Title",(0,t.jsx)(n.br,{}),"\n","How to Reduce Recognition Complexity in Data Ingestion"]}),"\n",(0,t.jsxs)(n.p,{children:["Subtitle",(0,t.jsx)(n.br,{}),"\n","Design patterns for turning messy source systems into simple, trustworthy ingestion flows."]}),"\n",(0,t.jsxs)(n.p,{children:["Suggested Tags",(0,t.jsx)(n.br,{}),"\n","Data Engineering, ETL, CDC, Data Modeling, SaaS"]}),"\n",(0,t.jsx)(n.p,{children:"Body"}),"\n",(0,t.jsxs)(n.p,{children:["If you work on data platforms long enough, you eventually realize that ",(0,t.jsx)(n.strong,{children:"ingestion is not just about moving data"}),". It is about ",(0,t.jsx)(n.strong,{children:"recognizing what the data actually means"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"That recognition step is where most of the hidden complexity lives:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Which tables belong to which business domain?"}),"\n",(0,t.jsx)(n.li,{children:"Which flags and status codes are actually used, and which are historical noise?"}),"\n",(0,t.jsx)(n.li,{children:"Which fields can we trust as keys, and which are \u201cbest effort\u201d?"}),"\n",(0,t.jsx)(n.li,{children:"How do we stitch CDC streams, files, and APIs into one coherent picture?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If you don\u2019t solve this \u201crecognition complexity\u201d well, your ingestion layer becomes a museum of ad\u2011hoc scripts, one\u2011off mappings, and fragile pipelines. Every new source feels like starting from zero."}),"\n",(0,t.jsx)(n.p,{children:"In this article, I\u2019ll share how we approach this problem in Watchmen\u2019s Collector, and a set of patterns you can apply even if you\u2019re not using Watchmen."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"the-real-problem-recognition-not-just-extraction",children:"The Real Problem: Recognition, Not Just Extraction"}),"\n",(0,t.jsxs)(n.p,{children:["Most ingestion stacks focus on ",(0,t.jsx)(n.strong,{children:"how"})," to read data:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Connectors for different databases and SaaS tools,"}),"\n",(0,t.jsx)(n.li,{children:"CDC vs batch,"}),"\n",(0,t.jsx)(n.li,{children:"File formats: CSV, Parquet, JSON, etc."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Those are necessary, but they don\u2019t address the hardest part:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"\u201cGiven all these tables/files/topics, which ones matter, how do they relate, and what business facts do they represent?\u201d"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["We call this the ",(0,t.jsx)(n.strong,{children:"recognition problem"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Symptoms that recognition complexity is out of control:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Your ingestion DAG is a tangled graph of table\u2011level jobs with cryptic names."}),"\n",(0,t.jsx)(n.li,{children:"Adding a new domain requires reading tribal knowledge from three different engineers."}),"\n",(0,t.jsx)(n.li,{children:"The same source field is interpreted differently in three different pipelines."}),"\n",(0,t.jsx)(n.li,{children:"Every time an upstream schema changes, downstream teams spend weeks \u201cfixing mappings\u201d."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The question is: how do we design ingestion so that ",(0,t.jsx)(n.strong,{children:"recognition is simple, repeatable, and explicit"}),"?"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-1-separate-source-view-from-domain-view",children:"Pattern 1: Separate \u201cSource View\u201d from \u201cDomain View\u201d"}),"\n",(0,t.jsx)(n.p,{children:"The first step is conceptual: stop treating source tables as your primary model."}),"\n",(0,t.jsx)(n.p,{children:"Instead, we separate the world into two layers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source View"}),(0,t.jsx)(n.br,{}),"\n","How data physically exists in each system: tables, columns, formats, APIs."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Domain View"}),(0,t.jsx)(n.br,{}),"\n","How the business thinks about reality: Orders, Customers, Policies, Claims, Events."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In Watchmen\u2019s Collector, this is reflected as:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tables"}),": configuration of how to extract from a specific source (DB table, file path, topic)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Models"}),": domain\u2011level entities and mappings that describe what those sources mean."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Extraction is about the Source View. Recognition happens in the mapping from Source View to Domain View."}),"\n",(0,t.jsx)(n.p,{children:"Practical implications:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Naming conventions and contracts live at the ",(0,t.jsx)(n.strong,{children:"Model"})," level, not at the table level."]}),"\n",(0,t.jsx)(n.li,{children:"When a source system changes, you adjust the Source View configuration and remap to the same Model, rather than rewriting everything downstream."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-2-introduce-ingestion-modules-per-domain",children:"Pattern 2: Introduce Ingestion Modules per Domain"}),"\n",(0,t.jsx)(n.p,{children:"Another common source of complexity is mixing multiple business domains in the same ingestion DAG."}),"\n",(0,t.jsx)(n.p,{children:"Payments, Orders, Users, and Logs end up as one giant graph of jobs. It\u2019s hard to answer simple questions like:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u201cIs the Orders domain ingestion healthy right now?\u201d"}),"\n",(0,t.jsx)(n.li,{children:"\u201cWhich tables/files belong to the Policy domain?\u201d"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To reduce this, we group everything by ",(0,t.jsx)(n.strong,{children:"Module"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"Module"})," is a coherent ingestion domain (e.g., \u201cGL\u201d, \u201cPolicy\u201d, \u201cCustomer 360\u201d)."]}),"\n",(0,t.jsx)(n.li,{children:"Each module contains its own models, tables, and configuration."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This yields a few benefits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You can reason about ingestion ",(0,t.jsx)(n.strong,{children:"per domain"})," instead of staring at a global DAG."]}),"\n",(0,t.jsx)(n.li,{children:"Ownership becomes clearer: you can assign module\u2011level ownership to teams."}),"\n",(0,t.jsx)(n.li,{children:"Experiments and configuration changes are isolated: tweaking batch size for GL ingestion does not affect Customer ingestion."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In Watchmen, the Collector UI literally surfaces Modules as first\u2011class cards: you click into one module and see only the models, tables, and tasks relevant to that domain."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-3-make-mapping-explicit-and-validated",children:"Pattern 3: Make Mapping Explicit and Validated"}),"\n",(0,t.jsx)(n.p,{children:"Mapping is where recognition happens:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Which source fields map to which domain attributes?"}),"\n",(0,t.jsx)(n.li,{children:"How do we convert types, normalize codes, and handle nulls?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In many stacks, this mapping is buried in custom scripts or scattered SQL. That makes it hard to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand what a pipeline is really doing,"}),"\n",(0,t.jsx)(n.li,{children:"Detect breaking changes early,"}),"\n",(0,t.jsx)(n.li,{children:"Reuse mappings across pipelines."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Instead, treat mapping as a ",(0,t.jsx)(n.strong,{children:"first\u2011class artifact"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Define mappings at the Model level:",(0,t.jsx)(n.br,{}),"\n","\u201cThis domain attribute comes from this source field, with this transformation.\u201d"]}),"\n",(0,t.jsx)(n.li,{children:"Validate mappings before you connect them to actual tables."}),"\n",(0,t.jsx)(n.li,{children:"Version mappings as your domain evolves."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This reduces recognition complexity because:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"New engineers can read the Model and immediately see how data is interpreted."}),"\n",(0,t.jsx)(n.li,{children:"When a source schema changes, you see exactly which models and attributes are affected."}),"\n",(0,t.jsx)(n.li,{children:"You can test mapping correctness independently from the extraction implementation."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-4-design-ingestion-as-tasks-not-scripts",children:"Pattern 4: Design Ingestion as Tasks, Not Scripts"}),"\n",(0,t.jsx)(n.p,{children:"Recognition complexity grows when ingestion logic is hidden inside long\u2011running scripts with too much responsibility."}),"\n",(0,t.jsxs)(n.p,{children:["We prefer to think in terms of ",(0,t.jsx)(n.strong,{children:"tasks"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u201cExtract full customer snapshot from System A\u201d"}),"\n",(0,t.jsx)(n.li,{children:"\u201cCapture incremental changes for Orders from binlog\u201d"}),"\n",(0,t.jsx)(n.li,{children:"\u201cNormalize GL entries and write domain events\u201d"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each task has:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A clear trigger (manual, cron, or event\u2011based),"}),"\n",(0,t.jsx)(n.li,{children:"A well\u2011defined scope (module, model, table),"}),"\n",(0,t.jsx)(n.li,{children:"A lifecycle (pending, running, succeeded, failed),"}),"\n",(0,t.jsx)(n.li,{children:"Metrics and logs."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Organizing ingestion as tasks brings several advantages:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You can trace exactly what ran, when, and with which configuration."}),"\n",(0,t.jsx)(n.li,{children:"Retries and backoff policies are handled centrally rather than re\u2011implemented in every script."}),"\n",(0,t.jsx)(n.li,{children:"It becomes much easier to answer \u201cwhat is the ingestion status for this domain?\u201d."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In Watchmen Collector, the Surface layer exposes routes for configuring, triggering, and monitoring tasks, and the Kernel executes them with a unified runtime."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-5-normalize-early-deliver-flexibly",children:"Pattern 5: Normalize Early, Deliver Flexibly"}),"\n",(0,t.jsx)(n.p,{children:"A lot of recognition complexity comes from trying to support many different targets and consumers directly from raw sources."}),"\n",(0,t.jsx)(n.p,{children:"Instead, we aim for:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Normalize as early as possible"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Turn raw source records into a unified event or domain record,"}),"\n",(0,t.jsx)(n.li,{children:"Apply mappings, type corrections, and basic validation."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Deliver to multiple targets from the normalized form"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Warehouse (for analytics),"}),"\n",(0,t.jsx)(n.li,{children:"Queue or topic (for real\u2011time consumers),"}),"\n",(0,t.jsx)(n.li,{children:"Downstream APIs or services."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By separating normalization from delivery:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Recognition complexity is dealt with once, in a controlled place."}),"\n",(0,t.jsx)(n.li,{children:"Adding a new target (a new warehouse, a new queue) doesn\u2019t require touching source\u2011level logic."}),"\n",(0,t.jsx)(n.li,{children:"Your ingestion pipeline becomes more robust to change: as long as you maintain the normalized form, consumers can evolve independently."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"putting-it-all-together-in-a-saas-data-platform",children:"Putting It All Together in a SaaS Data Platform"}),"\n",(0,t.jsx)(n.p,{children:"In a SaaS setting, you typically have:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Many tenants,"}),"\n",(0,t.jsx)(n.li,{children:"Many different source systems,"}),"\n",(0,t.jsx)(n.li,{children:"A small platform team trying to provide consistent ingestion patterns."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Recognition complexity scales with:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The number of domains,"}),"\n",(0,t.jsx)(n.li,{children:"The diversity of source schemas,"}),"\n",(0,t.jsx)(n.li,{children:"The number of teams interpreting the same data."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The patterns above help you keep that under control:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modules"})," give each domain a clear boundary."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Models"})," and explicit mappings document what the data actually means."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tasks"})," provide a unified runtime and monitoring model."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Early normalization"})," turns messy sources into a stable contract."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This is the philosophy behind Watchmen\u2019s Collector: it is not just a connector layer; it is a ",(0,t.jsx)(n.strong,{children:"recognition layer"})," for your data platform."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"final-thoughts",children:"Final Thoughts"}),"\n",(0,t.jsx)(n.p,{children:"If ingestion feels hard, it is probably not because your connectors are bad. It is because recognition\u2014the act of understanding and encoding what data means\u2014has been left implicit."}),"\n",(0,t.jsx)(n.p,{children:"By:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Separating source view from domain view,"}),"\n",(0,t.jsx)(n.li,{children:"Grouping ingestion into domain modules,"}),"\n",(0,t.jsx)(n.li,{children:"Making mappings explicit and validated,"}),"\n",(0,t.jsx)(n.li,{children:"Treating ingestion as tasks instead of scripts,"}),"\n",(0,t.jsx)(n.li,{children:"Normalizing early and delivering flexibly,"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"you can dramatically reduce recognition complexity in your ingestion layer."}),"\n",(0,t.jsx)(n.p,{children:"The result is a platform where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"New sources feel like extension, not reinvention,"}),"\n",(0,t.jsx)(n.li,{children:"New team members can understand ingestion flows by reading models and tasks,"}),"\n",(0,t.jsx)(n.li,{children:"And your downstream analytics and decision systems finally sit on top of data that everyone agrees on."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);